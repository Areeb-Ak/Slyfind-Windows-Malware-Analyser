import { Worker } from 'worker_threads'
import { readdirSync } from 'fs'
import { join } from 'node:path'
import { exec } from 'child_process'
import { promises as fs1 } from 'fs'

function runModule(memdump) {
  return new Promise((resolve, reject) => {
    let modules = ['pslist', 'dlllist', 'handles', 'malfind', 'modules', 'svcscan', 'callbacks']
    let completedWorkers = 0

    const handleWorkerCompletion = () => {
      completedWorkers++
      if (completedWorkers === modules.length) {
        console.log('All workers completed')
        resolve()
      }
    }
    for (let i = 0; i < modules.length; i++) {
      const worker = new Worker(join(__dirname, '../../src/utils/worker.js'))

      // Listening for messages from the worker thread
      worker.on('message', () => {
        worker.terminate()
        handleWorkerCompletion()
      })
      worker.on('error', (error) => {
        console.error(`Error in worker: ${error}`)
        reject(error)
      })

      // Sending data to the worker thread
      let command = `${memdump}^${modules[i]}`
      worker.postMessage(command)
    }
  })
}

async function ldr_async(memdump, plugin) {
  try {
    const command = `python3 v3/vol.py -f ${memdump} windows.${plugin}`
    console.log('Command (Non-Worker):', plugin)
    const { stdout } = exec(command)

    const outputFile = join(__dirname, '../../src/output', `${plugin}.txt`)

    await fs1.writeFile(outputFile, stdout)
    console.log('\nCacheing complete\n')
    return stdout
  } catch (error) {
    console.log(error)
  }
}

function listRawFilesWithSpaces() {
  let result = ''
  let memfile = 'exec'
  readdirSync(join(__dirname, `../../src/${memfile}`)).forEach((file) => {
    if (file.endsWith('.raw') || file.endsWith('.mem') || file.endsWith('.dmp')) {
      const filePath = join(__dirname, `../../src/${memfile}`, file)
      result += filePath
    } else {
      return false
    }
  })
  return result
}

export { listRawFilesWithSpaces, ldr_async, runModule }
